# 7. 动态规划



### 7.1 动态规划讲解



动态规划算法通常基于一个递推公式及一个或多个初始状态。 当前子问题的解将由上一次子问题的解推出。使用动态规划来解题只需要多项式时间复杂度， 因此它比回溯法、暴力法等要快许多。



动态规划三步走：

一 定义子问题
二 找出循环表示
三 解决基本示例。

动态规划的难点在于，一方面，我们需要把问题状态化，拆分各种子状态，并且将状态用状态方程来表示。另一方面，即使我们获得状态方程了，用代码的形式来表达的时候，仍然存在一定的转化难题，包括边界值。



### 7.2 股票问题



**122. 买卖股票的最佳时机 II**



给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。

设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。

注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。



**输入输出示例**



输入: [7,1,5,3,6,4]
输出: 7
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。



**题解**



（1） 子问题

如果当前的状态有，拥有股票，没有拥有股票；在基于两种状态下的获取的最大利润。

（2)  循环表示

在下一天的状态也是两种，拥有股票（上一天拥有股票+不卖；或者，上一天没有股票+买）；没有拥有股票也同样可以这样分析。这样，就可以同种这种状态转移循环表示了。

（3）基本示例

初始化，记第$i$ 天拥有股票的最大收益为 $dp[i][1]$, 第$i$ 天没有拥有股票的最大收益为 $dp[i][0]$.



```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        dp = [[0 for j in range(2)] for i in range(len(prices))] 
        # init
        for i in range(len(prices)):
            dp[i][0] = max( (dp[i-1][0] if i>=1 else 0), (dp[i-1][1] if i>=1 else -float('inf')) + prices[i])
            dp[i][1] = max( (dp[i-1][1] if i>=1 else -float('inf')), (dp[i-1][0] if i>=1 else 0) - prices[i])
        return dp[len(prices)-1][0]
```





